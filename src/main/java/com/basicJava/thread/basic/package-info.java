/**
 * Created by zhouyifu on 2017/10/11.
 */
package com.basicJava.thread.basic;
/*
* Java并发编程基础
*
*   什么是线程？
*       现代操作系统调度的做小单元；
*       一个进程可以创建多个线程，每个线程拥有自己的计数器、堆栈、局部变量等属性，同时可以访问共享的内存变量；
*   CPU在线程之前高速切换，使之有同时执行的感觉。
*
*   为什么使用多线程？
*       更多的处理器核心；
*       更快的响应时间
*       更好地编程模型
*
*   线程的优先级
*       1-10个级别，默认是5；
*       注意:程序的正确性不能依赖线程的优先级高低。
*
*   线程的状态
*       NEW;
*       RUNNABLE;
*       BLOCKED;
*       WAITING;
*       TIME_WAITING;
*       TERMINATED;
*
*   Daemon线程
*       一种支持型线程。用于程序中后台调度及支持性工作。
*       注意：当一个Java虚拟机中不存在非Daemon线程时，Java虚拟机将会退出。
*       可以通过Thread.setDaemon(true)将线程设置为Daemon线程
*       注意：在构建Daemon线程时，不能依靠finall块中的内容来确保执行关闭或清理资源的逻辑
*
*    启动和终止线程
*       构造线程：需要提供：线程组、优先级、是否是Daemon线程等信息
*       启动线程：start()；其含义是：当前线程（即parent线程）同步告知Java虚拟机，只要线程规划器空闲，立即启动该线程
*       理解中断：线程的一个标志位属性，它表示一个运行中的线程是否被其他线程进行了中断。(见Interrupted.java类)
*       如何安全的终止线程： 见Shutdown.java
*
*
*    线程间通信
*       volatile关键字：告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，以保证可见性。
*       注意：过多的使用它会降低程序的效率。
*       synchronized关键字：确保多个线程在同一时刻，只能有一个线程处于方法或者同步块中，保证了线程对变量访问的可见性和排他性。
*       对象、对象的监视器、同步队列、执行线程之间的关系：
*           线程想要对Object（Object由Synchronized保护）进行访问
*           -> 首先需要获得Object的监视器
*           -> 获取监视器成功，则可访问
*           -> 获取监视器失败，则该线程进入同步队列，状态变为阻塞，直到拥有锁的线程释放了锁，会唤醒同步队列中的线程，再次尝试进行对监视器的获取操作
*
*   等待/通知机制
*       notify()、notifyAll()、wait()、wait(long)、wait(long,int)
*       见WaitNotify.java
*       注意点：
*           - 先对调用对象枷锁，再调用notify()、notifyAll()、wait()
*           - wait()方法使线程状态由Running变为Waiting，同时线程被放置到等待队列
*           - notify()、notifyAll()被调用后，等待线程不会立即从wait()返回，需要有锁的那个线程先释放锁以后，才有机会从wait()返回
*           - notify()、notifyAll()的操作是将等待队列中的线程放置到同步队列中，同时被移动的线程状态由Waiting转变为Blocked（不同的是，前者只放一个，后者放置所有线程）。
*           - wait()能够返回，前提是获得了锁。
*       经典范式：生产者/消费者模式
*           等待方遵循如下原则：
*               - 获取对象锁
*               - 如果条件不满足，进行wait()操作，被通知后仍要检查条件。
*               - 条件满足则执行对应的条件
*           通知方遵循如下原则：
*               - 获取对象锁
*               - 改变条件
*               - 通知所有等待在对象上的线程
*
*   管道输入/输出流
*       主要用于线程之间的数据传输，而传输的媒介为内存
*       4种具体实现：
*           - PipedOutputStream、PipedInputStream、PipedReader、PipedWriter
*       见Piped.java
*
*   Thread.join()的使用
*       当线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才从thread.join()返回。
*       见Join.java
*       join()方法的逻辑结构和等待/通知经典范式一致，即加锁、循环和处理逻辑3个步骤
*
*   ThreadLocal的使用
*       ThreadLocal，即线程变量。键值存储结构。
*       一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。
*       见Profiler.java
*
*   线程实例
*       等待超时模式:
*           使用场景：调用一个方法时等待一段时间，能在时间内返回，则立即返回，超时，返回默认结果。
*           基本点：等待持续时间 REMAINING = T 、超时时间 FUTURE = now + T
*           见TimeoutPattern.java
*
*       一个简单的数据库连接池实例：
*           重点是：使用等待超时模式，在获取连接的过程，
*           如果有连接则直接返回；
*           如果没有，则wait(mills),在其他线程释放连接时被唤醒，如果超时未被唤醒，返回null。
*       线程池技术：
*           本质：一个线程安全的任务队列，它连接了工作者线程和客户端线程。工作者线程中，不断地在任务队列中获取任务，没有任务
*           就wait，直到在任务队列中新增一个任务后notify唤醒。
*
*
* */