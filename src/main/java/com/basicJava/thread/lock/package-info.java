/**
 * Created by zhouyifu on 2017/10/11.
 */
package com.basicJava.thread.lock;
/*
关于锁的相关操作。
简单的说明：
思考流程：
竞态条件的出现会造成错误
↑
有些情况可以采取加锁的操作解决
↑
要根据需要实现锁，核心是实现同步器
↑
同步器是基于模板方法模式（即通过继承同步器，重写相应的模板方法实现）
↑
同步器提供的模板方法基本上分为3类：
- 独占式获取与释放同步状态
- 共享式获取与释放同步状态
- 查询同步队列中的等待线程情况

到Mutex.java类中看独占锁的基本实现。

    同步器：
        知道了想自定义锁，要实现同步器，那么同步器是如何保证线程同步的？
            - 同步队列
            - 独占式同步状态获取与释放
            - 共享式同步状态获取与释放
            - 独占式超时获取同步状态

        同步队列：
            依赖一个FIFO双向队列来完成同步状态的管理，当前线程获取同步状态失败时，同步器将当前线程
            的相关信息构造成一个Node放入同步队列，阻塞线程；当同步状态释放时，会把首节点中的线程唤醒，
            使其再次尝试获取同步状态。

        独占式同步状态获取与释放：
            调用acquire()方法可以获取同步状态，该方法对中断不敏感，即获取同步状态失败被放入同步队列中后，
            中断该线程，该线程不会从同步队列中移出。

            逻辑流程：同步器维护一个同步队列，线程在获取同步状态失败后，加入队列，并进行自旋；当前驱节点为
            头节点同时头节点成功获取了同步状态时，该节点再次尝试获取同步状态，如果成功则移出队列（停止自旋）。

        共享式同步状态获取与释放：
            共享式与独占式的主要区别：
                - 共享式访问资源的时候，其他共享访问均被允许，而独占式访问被阻塞；
                - 独占式访问资源的时候，同一时刻其他访问均被阻塞

        独占式超时获取同步状态：
            在指定时间内获取同步状态，还如果获取到同步状态则返回true
            这个过程和独占式同步获取的过程相似，但是在同步状态获取失败的处理上有所不同

        自定义同步组件
            假设需要实现一个同步工具：同时只允许至多两个线程同时访问，超过两个线程的访问将被阻塞
            - 确定访问模式：同时允许两个线程访问，那么显然是共享式访问
            - 定义资源数：同时允许两个线程访问，表明同步资源数为2。那么，初始状态staus为2，获取一个线程则staus减1，线程释放则加1。为0时则阻塞
           见TwinsLock.java

    重入锁
        什么是重入锁？
            支持重进入的锁，它表示锁能够支持一个线程对资源的重复加锁（能够满足占有线程再次获取锁的要求）。除此以外，还支持获取锁时的公平和非公平选择
        锁的公平性：
            在绝对时间上，先对锁进行获取请求的一定先满足，那么这个锁是公平的。  事实上，公平的锁机制往往没有非公平的效率高

        1. 实现重进入
            重进入是指任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞。实现这个特性需要解决下面两个问题：
            - 线程再次获取锁。锁发现获取锁的线程就是当前占据锁的线程时，仍能成功获取
            - 锁的最终释放。一个线程重复n次获取锁，随后在第n次释放该锁后，其他线程能够获取到该锁




 */